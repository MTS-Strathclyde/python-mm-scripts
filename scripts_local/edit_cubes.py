#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 15 11:02:03 2016

@author: max
"""

from __future__ import print_function, division
import argparse
import sys
import numpy as np
from math import ceil, floor, sqrt


def process_command_line(argv):
    """Processes arguments

    Parameters
    ----------
    argv : list
        Command line arguments.

    Returns
    -------
    out : argparse.Namespace
        Namespace of command line arguments.
    """
    parser = argparse.ArgumentParser(description="""Edit cube files.""")
    #Positional args
    parser.add_argument('cubes',
                        help="""Cube files""", nargs='+')
    parser.add_argument('-n', '--name',
                        help=""" Output name [processed].""",
                        default='processed')
    parser.add_argument('--charge', help="""Add nuclei charge to charge density""",
                        action='store_true')
    parser.add_argument('--merge', help="""Merge all cubes""",
                        action='store_true')
    parser.add_argument('--reduce', help=""" Project data to z axis""",
                        action='store_true')
    return parser.parse_args(argv)
    
 
class Cube:
    def __init__(self, fname):
        f = open(fname, 'r')
        for i in range(2): 
            f.readline()
        tkns = f.readline().split() # number of atoms included in the file followed by the
        #position of the origin of the volumetric data
        self.fname = fname
        self.natoms = int(tkns[0])
        self.origin = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
    # The next three lines give the number of voxels along each axis (x, y, z) followed by the axis vector.
        tkns = f.readline().split() #
        self.NX = int(tkns[0])
        self.X = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NY = int(tkns[0])
        self.Y = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NZ = int(tkns[0])
        self.Z = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
    # For cube cells with axes perpendicular to each other
        self.dx = self.X[0]
        self.x_lim = self.dx*self.NX
        self.dy = self.Y[1]
        self.y_lim = self.dy*self.NY
        self.dz = self.Z[2]
        self.z_lim = self.dz*self.NZ
        self.voxel = self.dx*self.dy*self.dz
    # The last section in the header is one line for each atom consisting of 
    #5 numbers, the first is the atom number, second (?), the last three are the x,y,z coordinates of the atom center. 
        self.atoms = []
        for i in range(self.natoms):
            tkns = f.readline().split()
            x, y, z = float(tkns[2])%self.x_lim, float(tkns[3])%self.y_lim, float(tkns[4])%self.z_lim
            self.atoms.append([int(float(tkns[0])), x, y, z])
        self.atoms = np.array(self.atoms)
    # Volumetric data
        self.data = np.zeros((self.NX,self.NY,self.NZ))
        i=0
        for s in f:
            for v in s.split():
                self.data[i/(self.NY*self.NZ), (i/self.NZ)%self.NY, i%self.NZ] = float(v)
                i+=1
        if i != self.NX*self.NY*self.NZ:
            raise NameError, "FSCK!"
   
    def dump(self, f):
        # output Gaussian cube into file descriptor "f". 
        # Usage pattern: f=open('filename.cube'); cube.dump(f); f.close()
        f.write("CUBE file\ngenerated by python\n")
        f.write("%4d %.6f %.6f %.6f\n" % (self.natoms, self.origin[0], self.origin[1], self.origin[2]))
        f.write("%4d %.6f %.6f %.6f\n"% (self.NX, self.X[0], self.X[1], self.X[2]))
        f.write("%4d %.6f %.6f %.6f\n"% (self.NY, self.Y[0], self.Y[1], self.Y[2]))
        f.write("%4d %.6f %.6f %.6f\n"% (self.NZ, self.Z[0], self.Z[1], self.Z[2]))
        for atom in self.atoms:
            f.write("%s %d %s %s %s\n" % (atom[0], 0, atom[1], atom[2], atom[3]))
        for ix in xrange(self.NX):
            for iy in xrange(self.NY):
                for iz in xrange(self.NZ):
                    f.write("%.5e " % self.data[ix,iy,iz])
                    if (iz % 6 == 5): 
                        f.write('\n')
                f.write('\n')
 
    def mask_sphere(self, R, Cx,Cy,Cz):
# produce spheric volume mask with radius R and center @ [Cx,Cy,Cz]
# can be used for integration over spherical part of the volume
        m=0*self.data
        for ix in xrange( int(ceil((Cx-R)/self.X[0])), int(floor((Cx+R)/self.X[0])) ):
            ryz=sqrt(R**2-(ix*self.X[0]-Cx)**2)
            for iy in xrange( int(ceil((Cy-ryz)/self.Y[1])), int(floor((Cy+ryz)/self.Y[1])) ):
                rz=sqrt(ryz**2 - (iy*self.Y[1]-Cy)**2)
                for iz in xrange( int(ceil((Cz-rz)/self.Z[2])), int(floor((Cz+rz)/self.Z[2])) ):
                    m[ix,iy,iz]=1
        return m
    
    def _gen_grid(self):
        """Return meshgrid with x, y, z"""
        return np.mgrid[0:self.x_lim:self.dx, 0:self.y_lim:self.dy, 0:self.z_lim:self.dz]
    
    def add_atom_charges(self):
        """Add atom charges to data. Assume that we have only 1st, 2nd row atoms.
        Time consuming."""
        # we had electrons, so first of all we need to change charge
        self.data = -self.data
        for chg, x_atom, y_atom, z_atom in self.atoms:
            # remove core electrons from 2nd row, but ignore H
            chg = abs(chg - 2)
            # find atoms closest grid points
            x_idx = int(round(x_atom/self.dx)) % self.NX
            y_idx = int(round(y_atom/self.dy)) % self.NY
            z_idx = int(round(z_atom/self.dz)) % self.NZ
            # add chg to data
            self.data[x_idx, y_idx, z_idx] += chg/self.voxel
        # finished looping
        
    def add_to_self(self, other):
        """Simply adds data"""
        assert self.NX == other.NX
        assert self.NY == other.NY
        assert self.NZ == other.NZ
        self.data = (self.data + other.data)/2.0


def process(args, cube):
    print(cube)
    if args.charge:
        cube.add_atom_charges()
    if args.reduce:
        z = np.arange(0, cube.z_lim, cube.dz)
        z_avg = np.sum(cube.data, axis=(0,1))*cube.dx*cube.dz/(cube.x_lim*cube.y_lim)
        reduced_arr = np.c_[z, z_avg]
        np.savetxt(args.name + '_' + cube.fname, reduced_arr)


def main(argv):
    args = process_command_line(argv)
    cube0 = Cube(args.cubes[0])
    process(args, cube0)
    for fname in args.cubes[1:]:
        cube = Cube(fname)
        process(args, cube)
        if args.merge:
            cube0.add_to_self(cube)
    if args.merge:
        f = open(args.name, 'w')
        cube0.dump(f)
        f.close()
            

if __name__ == '__main__':
    main(sys.argv[1:])    


